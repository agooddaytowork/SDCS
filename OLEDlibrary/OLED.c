/*
 * OLED.c
 *
 *  Created on: Jul 4, 2015
 *      Author: Dinh
 */

#include "OLED.h"
#include <stdint.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include "../TimeOut.h"
#define HIGH 1
#define LOW 0

uint8_t OLED_display_array[3][7];
uint8_t OLED_status = 0;
uint8_t OLED_CTRL = 0;

uint8_t OLED_clear_x = 0;
uint8_t OLED_clear_y = 0;
uint8_t OLED_clear_width = 0;
uint8_t OLED_clear_height = 0;

uint8_t OLED_setCursor_x = 0;
uint8_t OLED_setCursor_y = 0;

uint8_t ContentArray[100];
uint8_t EGunstage[6];
uint8_t m_col;
uint8_t m_row;

extern uint8_t IdleMode;
const unsigned char CAN_icon[] =
{ 0x3C, 0x7E, 0xFF, 0xC3, 0x81, 0x81, 0x42, 0x24, };

const unsigned char arrow8x8[] =
{ 0x81, 0x66, 0x7E, 0x3C, 0x3C, 0x18, 0x18, 0x00, };

const unsigned char KLAsmall[] =
{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x08, 0x0C, 0x1C,
		0xFC, 0xF8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0x7F, 0x70, 0xF8, 0xFC,
		0x8E, 0x07, 0x03, 0x01, 0x00, 0xFC, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0xC0,
		0xE0, 0xF8, 0x3E, 0x0F, 0x0F, 0xFF, 0xFE, 0xC0, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x03, 0xC3, 0xFF, 0xFF, 0x0F, 0x03, 0xE3, 0xF0,
		0x78, 0x58, 0x48, 0x58, 0x70, 0x60, 0x00, 0xC0, 0xF8, 0xF8, 0x10, 0x10,
		0x18, 0xF8, 0xF0, 0x00, 0x80, 0xE0, 0xF0, 0x38, 0x18, 0x18, 0x18, 0x00,
		0xE0, 0xF0, 0x38, 0x18, 0x18, 0x38, 0xF8, 0xF0, 0x00, 0x00, 0xF0, 0xF8,
		0x78, 0x30, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07,
		0x00, 0x00, 0x00, 0x03, 0x07, 0x07, 0x04, 0x00, 0x06, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x03, 0x00, 0x00, 0xFC, 0xFF, 0x8F, 0x07, 0x07,
		0x00, 0x80, 0xC0, 0x60, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x07, 0x07, 0x03,
		0x00, 0x00, 0x03, 0x07, 0x06, 0x06, 0x06, 0x06, 0x02, 0x00, 0x00, 0x07,
		0x07, 0x00, 0x00, 0x00, 0x06, 0x07, 0x03, 0x00, 0x01, 0x03, 0x07, 0x06,
		0x06, 0x06, 0x00, 0x00, 0x03, 0x07, 0x07, 0x06, 0x06, 0x07, 0x03, 0x01,
		0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
		0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00 };

const unsigned char digits8x8[][8] =
{
{ 0x3C, 0x7E, 0x83, 0x81, 0x81, 0x7E, 0x3C, 0x00 },/*0*/
{ 0x84, 0x84, 0x82, 0xFF, 0xFF, 0x80, 0x80, 0x00 },/*1*/
{ 0x84, 0xC6, 0xE1, 0xA1, 0xB1, 0x9F, 0x8E, 0x00 },/*2*/
{ 0x42, 0xC3, 0x81, 0x89, 0x89, 0xFF, 0x76, 0x00 },/*3*/
{ 0x20, 0x38, 0x24, 0x22, 0xFF, 0xFF, 0x20, 0x00 },/*4*/
{ 0x5F, 0xDF, 0x99, 0x89, 0x89, 0xF9, 0x70, 0x00 },/*5*/
{ 0x3C, 0x7E, 0x89, 0x89, 0x89, 0xFB, 0x72, 0x00 },/*6*/
{ 0x01, 0x01, 0xE1, 0xF9, 0x1D, 0x07, 0x01, 0x00 },/*7*/
{ 0x6E, 0xFF, 0x89, 0x89, 0x99, 0xFF, 0x76, 0x00 },/*8*/
{ 0x4E, 0xDF, 0x91, 0x91, 0x91, 0x7F, 0x3E, 0x00 }, /*9*/
};

// The 7-bit ASCII character set...
const unsigned char font5x8[][5] =
{
{ 0x00, 0x00, 0x5f, 0x00, 0x00 },  // 21 !
		{ 0x00, 0x07, 0x00, 0x07, 0x00 },  // 22 "
		{ 0x14, 0x7f, 0x14, 0x7f, 0x14 },  // 23 #
		{ 0x24, 0x2a, 0x7f, 0x2a, 0x12 },  // 24 $
		{ 0x23, 0x13, 0x08, 0x64, 0x62 },  // 25 %
		{ 0x36, 0x49, 0x55, 0x22, 0x50 },  // 26 &
		{ 0x00, 0x05, 0x03, 0x00, 0x00 },  // 27 '
		{ 0x00, 0x1c, 0x22, 0x41, 0x00 },  // 28 (
		{ 0x00, 0x41, 0x22, 0x1c, 0x00 },  // 29 )
		{ 0x14, 0x08, 0x3e, 0x08, 0x14 },  // 2a *
		{ 0x08, 0x08, 0x3e, 0x08, 0x08 },  // 2b +
		{ 0x00, 0x50, 0x30, 0x00, 0x00 },  // 2c ,
		{ 0x08, 0x08, 0x08, 0x08, 0x08 },  // 2d -
		{ 0x00, 0x60, 0x60, 0x00, 0x00 },  // 2e .
		{ 0x20, 0x10, 0x08, 0x04, 0x02 },  // 2f /
		{ 0x3e, 0x51, 0x49, 0x45, 0x3e },  // 30 0
		{ 0x00, 0x42, 0x7f, 0x40, 0x00 },  // 31 1
		{ 0x42, 0x61, 0x51, 0x49, 0x46 },  // 32 2
		{ 0x21, 0x41, 0x45, 0x4b, 0x31 },  // 33 3
		{ 0x18, 0x14, 0x12, 0x7f, 0x10 },  // 34 4
		{ 0x27, 0x45, 0x45, 0x45, 0x39 },  // 35 5
		{ 0x3c, 0x4a, 0x49, 0x49, 0x30 },  // 36 6
		{ 0x01, 0x71, 0x09, 0x05, 0x03 },  // 37 7
		{ 0x36, 0x49, 0x49, 0x49, 0x36 },  // 38 8
		{ 0x06, 0x49, 0x49, 0x29, 0x1e },  // 39 9
		{ 0x00, 0x36, 0x36, 0x00, 0x00 },  // 3a :
		{ 0x00, 0x56, 0x36, 0x00, 0x00 },  // 3b ;
		{ 0x08, 0x14, 0x22, 0x41, 0x00 },  // 3c <
		{ 0x14, 0x14, 0x14, 0x14, 0x14 },  // 3d =
		{ 0x00, 0x41, 0x22, 0x14, 0x08 },  // 3e >
		{ 0x02, 0x01, 0x51, 0x09, 0x06 },  // 3f ?
		{ 0x32, 0x49, 0x79, 0x41, 0x3e },  // 40 @
		{ 0x7e, 0x11, 0x11, 0x11, 0x7e },  // 41 A
		{ 0x7f, 0x49, 0x49, 0x49, 0x36 },  // 42 B
		{ 0x3e, 0x41, 0x41, 0x41, 0x22 },  // 43 C
		{ 0x7f, 0x41, 0x41, 0x22, 0x1c },  // 44 D
		{ 0x7f, 0x49, 0x49, 0x49, 0x41 },  // 45 E
		{ 0x7f, 0x09, 0x09, 0x09, 0x01 },  // 46 F
		{ 0x3e, 0x41, 0x49, 0x49, 0x7a },  // 47 G
		{ 0x7f, 0x08, 0x08, 0x08, 0x7f },  // 48 H
		{ 0x00, 0x41, 0x7f, 0x41, 0x00 },  // 49 I
		{ 0x20, 0x40, 0x41, 0x3f, 0x01 },  // 4a J
		{ 0x7f, 0x08, 0x14, 0x22, 0x41 },  // 4b K
		{ 0x7f, 0x40, 0x40, 0x40, 0x40 },  // 4c L
		{ 0x7f, 0x02, 0x0c, 0x02, 0x7f },  // 4d M
		{ 0x7f, 0x04, 0x08, 0x10, 0x7f },  // 4e N
		{ 0x3e, 0x41, 0x41, 0x41, 0x3e },  // 4f O
		{ 0x7f, 0x09, 0x09, 0x09, 0x06 },  // 50 P
		{ 0x3e, 0x41, 0x51, 0x21, 0x5e },  // 51 Q
		{ 0x7f, 0x09, 0x19, 0x29, 0x46 },  // 52 R
		{ 0x46, 0x49, 0x49, 0x49, 0x31 },  // 53 S
		{ 0x01, 0x01, 0x7f, 0x01, 0x01 },  // 54 T
		{ 0x3f, 0x40, 0x40, 0x40, 0x3f },  // 55 U
		{ 0x1f, 0x20, 0x40, 0x20, 0x1f },  // 56 V
		{ 0x3f, 0x40, 0x38, 0x40, 0x3f },  // 57 W
		{ 0x63, 0x14, 0x08, 0x14, 0x63 },  // 58 X
		{ 0x07, 0x08, 0x70, 0x08, 0x07 },  // 59 Y
		{ 0x61, 0x51, 0x49, 0x45, 0x43 },  // 5a Z
		{ 0x00, 0x7f, 0x41, 0x41, 0x00 },  // 5b [
		{ 0x02, 0x04, 0x08, 0x10, 0x20 },  // 5c backslash
		{ 0x00, 0x41, 0x41, 0x7f, 0x00 },  // 5d ]
		{ 0x04, 0x02, 0x01, 0x02, 0x04 },  // 5e ^
		{ 0x40, 0x40, 0x40, 0x40, 0x40 },  // 5f _
		{ 0x00, 0x01, 0x02, 0x04, 0x00 },  // 60 `
		{ 0x20, 0x54, 0x54, 0x54, 0x78 },  // 61 a
		{ 0x7f, 0x48, 0x44, 0x44, 0x38 },  // 62 b
		{ 0x38, 0x44, 0x44, 0x44, 0x20 },  // 63 c
		{ 0x38, 0x44, 0x44, 0x48, 0x7f },  // 64 d
		{ 0x38, 0x54, 0x54, 0x54, 0x18 },  // 65 e
		{ 0x08, 0x7e, 0x09, 0x01, 0x02 },  // 66 f
		{ 0x0c, 0x52, 0x52, 0x52, 0x3e },  // 67 g
		{ 0x7f, 0x08, 0x04, 0x04, 0x78 },  // 68 h
		{ 0x00, 0x44, 0x7d, 0x40, 0x00 },  // 69 i
		{ 0x20, 0x40, 0x44, 0x3d, 0x00 },  // 6a j
		{ 0x7f, 0x10, 0x28, 0x44, 0x00 },  // 6b k
		{ 0x00, 0x41, 0x7f, 0x40, 0x00 },  // 6c l
		{ 0x7c, 0x04, 0x18, 0x04, 0x78 },  // 6d m
		{ 0x7c, 0x08, 0x04, 0x04, 0x78 },  // 6e n
		{ 0x38, 0x44, 0x44, 0x44, 0x38 },  // 6f o
		{ 0x7c, 0x14, 0x14, 0x14, 0x08 },  // 70 p
		{ 0x08, 0x14, 0x14, 0x18, 0x7c },  // 71 q
		{ 0x7c, 0x08, 0x04, 0x04, 0x08 },  // 72 r
		{ 0x48, 0x54, 0x54, 0x54, 0x20 },  // 73 s
		{ 0x04, 0x3f, 0x44, 0x40, 0x20 },  // 74 t
		{ 0x3c, 0x40, 0x40, 0x20, 0x7c },  // 75 u
		{ 0x1c, 0x20, 0x40, 0x20, 0x1c },  // 76 v
		{ 0x3c, 0x40, 0x30, 0x40, 0x3c },  // 77 w
		{ 0x44, 0x28, 0x10, 0x28, 0x44 },  // 78 x
		{ 0x0c, 0x50, 0x50, 0x50, 0x3c },  // 79 y
		{ 0x44, 0x64, 0x54, 0x4c, 0x44 },  // 7a z
		{ 0x00, 0x08, 0x36, 0x41, 0x00 },  // 7b {
		{ 0x00, 0x00, 0x7f, 0x00, 0x00 },  // 7c |
		{ 0x00, 0x41, 0x36, 0x08, 0x00 },  // 7d }
		{ 0x10, 0x08, 0x08, 0x10, 0x08 },  // 7e ~
		};

/*
 * HIGH 1 LOW 10 HIGH
 */

void OLED_RST(uint8_t status)
{
	if (status == HIGH)
	{
		MAP_GPIO_setOutputHighOnPin(GPIO_PORT_P6, GPIO_PIN0);
	}
	else
		MAP_GPIO_setOutputLowOnPin(GPIO_PORT_P6, GPIO_PIN0);
}
/*
 * Read_CanAddress
 * descrition: Read out the Can Address at CANADDRESS_START in FLASH MEMORY
 * return 255 if Address is not set
 */
uint8_t Read_CanAddress()
{
	uint8_t Array[2];
	Array[0] = 0;
	uint8_t *ReadMem_ptr;
	ReadMem_ptr = (uint8_t*) CANADDRESS_START;
	Array[0] = *ReadMem_ptr++;
	return Array[0];

}
/*
 * OLED_Main_Menu
 * Draw the menu Page
 */
void OLED_Main_Menu()
{
	memset(OLED_display_array, ' ', 21);
	OLED_display_array[1][0] = '1';
	OLED_display_array[1][1] = '2';
	OLED_display_array[1][2] = '3';
	OLED_display_array[1][3] = '4';
	OLED_display_array[1][4] = '5';
	OLED_display_array[1][5] = '6';
	OLED_display_array[0][6] = 0;
	OLED_display_array[1][6] = 0;
	OLED_display_array[2][6] = 0;

	OLEDclear(0, 0, 128, 32);
	//setCursor(0,1);
	//draw(arrow8x8,8,8);
	setCursor(20, 0);
	OLEDprint("Menu");
	setCursor(9, 1);
	OLEDprint("Start");
	setCursor(9, 2);
	OLEDprint("new ID:");
	setCursor(9, 3);
	sprintf((char *) ContentArray, "ID:%i", Read_CanAddress());
	OLEDprint(ContentArray);
	//setCursor(80, 0);
	/*
	 for (i = 1; i < 7; i++)
	 {
	 OLED_Station_display(i);
	 //OLED_Station_isConnected_display(i, 1);
	 }
	 */

	//OLED_Station_eGunisOn_display(1,1);
	//OLED_Station_isConnected_display(1,1);
}

/*
 * OLED_Address_Page
 * Draw The Address Page
 */
void OLED_Address_Page()
{
	OLEDclear(0, 0, 96, 64);
	setCursor(0, 0);
	OLEDprint("new ID:");

}

/*
 * OLED_Address_ChangeCANAddr
 * Change the can address from 1 - 9 by clicking the Left Button
 */
uint8_t OLED_Address_ChangeCANAddr()
{
	static uint8_t CAN_ADDRESS = 1;
	uint8_t chararray[20];
	OLEDclear(0, 16, 96, 8);
	setCursor(8, 2);
	draw(arrow8x8, 8, 8);
	sprintf((char *) chararray, "%i", CAN_ADDRESS);
	setCursor(18, 2);
	OLEDprint(chararray);

	CAN_ADDRESS++;
	if (CAN_ADDRESS > 10)
		CAN_ADDRESS = 1;

	return CAN_ADDRESS;

}

/*
 *
 */
void OLED_Start_Page()
{
	OLEDclear(0, 0, 128, 32);
	setCursor(0, 3);
	sprintf((char *) ContentArray, "ID:%i", Read_CanAddress());
	OLEDprint(ContentArray);
	setCursor(84, 1);
	OLEDprint("123456");
	// write station number

}

/*96 104 112 120
 * [i]*
 * Station display: i
 * Station is connected: []
 * Station eGun is On: *
 */
void OLED_Station_display(uint8_t StationNumber)
{
	setCursor(84, 0);
	OLEDprintln("******");
	OLEDprintln("123456");
	OLEDprintln("++++++");
}

/*
 *@Function: OLED_Station_isConnected_display
 *@Description: Display the square bracket around the station number
 *@Description: if the analog input of that station is attached.
 *@Parameter: StationNumber from 1-6, Status: 0 - 1
 *@Return: NULL
 */
void OLED_Station_isConnected_display(uint8_t StationNumber, uint8_t Status)
{

	if (Status)
	{
		OLED_display_array[0][StationNumber] = '+';

	}
	else
	{
		//OLEDclear((84 + ((StationNumber - 1)*5)), 0, 8, 8);
		OLED_display_array[0][StationNumber] = ' ';
	}

	if (IdleMode == 0)
	{
		setCursor(84, 0);
		OLEDprint(OLED_display_array[0]);
	}

}

/*
 *
 */
void OLED_Station_eGunisOn_display(uint8_t StationNumber, uint8_t Status)
{

	if (Status == 1)
	{
		if (EGunstage[(StationNumber)] == 0)
		{
			EGunstage[(StationNumber)] = 1;
			OLED_display_array[2][StationNumber] = '*';
		}

		//return;
	}
	else
	{
		//	setCursor(118, StationNumber);
		OLED_display_array[2][StationNumber] = ' ';
		//OLEDclear(120, (StationNumber+1) * 8, 8, 8);
		EGunstage[(StationNumber)] = 0;
		//OLEDclear(0,0,128,64);
		//return;
	}
	if (IdleMode == 0)
	{
		setCursor(84, 2);
		OLEDprint(OLED_display_array[2]);
	}

}

/*
 *
 */

void OLED_Gauge_detected_display(uint8_t Status)
{
	if (Status == 1)
	{
		setCursor(80, 7);
		OLEDprint((unsigned char*) "G");
	}
	else
	{
		OLEDclear(80, 7 * 8, 8, 8);
	}
}
uint8_t move_arrow()
{
	static uint8_t pos = 1;
	OLEDclear(0, 0, 8, 64);
	if (pos == 1)
	{
		setCursor(0, pos);
		pos = 2;
		draw(arrow8x8, 8, 8);
		return 1;
	}
	else
	{
		setCursor(0, pos);
		pos = 1;
		draw(arrow8x8, 8, 8);
		return 2;
	}

}

/*
 *
 */
void DrawLogo_small()
{
	OLEDclear(0, 0, 96, 64);
	setCursor(20, 0);
	draw(KLAsmall, 88, 32);
}

void Draw_CAN_icon(uint8_t status)
{
	if (status)
	{
		OLEDclear(70, 7 * 8, 8, 8);
		setCursor(70, 7);
		draw(CAN_icon, 8, 8);
	}
	else
	{
		OLEDclear(70, 7 * 8, 8, 8);
	}

}

void WriteCommand(unsigned char ins)
{

	addToI2CBuffer(0x00);
	addToI2CBuffer(ins);
	sendI2CBuffer();
}

void ShowLoadingScreen()
{
	OLEDclear(0, 0, 128, 64);
	draw(KLAsmall, 88, 32);
	setCursor(0, 4);
	OLEDprintln("IoT warehouse");
	OLEDprintln("monitoring system");
}

void OLEDsinglePrint(unsigned char *theString)
{
	OLEDclear(0, 0, 128, 56);
	OLEDprintwrap(theString);
}
void OLEDbegin()
{
	uint8_t i, j, k;

	MAP_GPIO_setAsOutputPin(GPIO_PORT_P2, GPIO_PIN5);
	// Init egunstage
	memset(EGunstage, 0, 6);
	OLED_RST(LOW);
	OLED_RST(LOW);
	OLED_RST(LOW);
	OLED_RST(LOW);
	OLED_RST(LOW);
	OLED_RST(HIGH);
	I2C_Init1();
	WriteCommand(SSD1306_DISPLAYOFF);                    // 0xAE
	WriteCommand(SSD1306_SETDISPLAYCLOCKDIV);            // 0xD5
	WriteCommand(0x80);                              // the suggested ratio 0x80
	WriteCommand(SSD1306_SETMULTIPLEX);                  // 0xA8
	WriteCommand(0x1F);
	WriteCommand(SSD1306_SETDISPLAYOFFSET);              // 0xD3
	WriteCommand(0x0);                                   // no offset
	WriteCommand(SSD1306_SETSTARTLINE | 0x0);            // line #0
	WriteCommand(SSD1306_CHARGEPUMP);                    // 0x8D
	{
		WriteCommand(0x14);
	}
	WriteCommand(SSD1306_MEMORYMODE);                    // 0x20
	WriteCommand(0x00);                                  // 0x0 act like ks0108
	WriteCommand(SSD1306_SEGREMAP | 0x1);
	WriteCommand(SSD1306_COMSCANDEC);
	WriteCommand(SSD1306_SETCOMPINS);                    // 0xDA
	WriteCommand(0x02);
	WriteCommand(SSD1306_SETCONTRAST);                   // 0x81
	WriteCommand(0x8F);
	WriteCommand(SSD1306_SETPRECHARGE);                  // 0xd9
	{
		WriteCommand(0xF1);
	}
	WriteCommand(SSD1306_SETVCOMDETECT);                 // 0xDB
	WriteCommand(0x40);
	WriteCommand(SSD1306_DISPLAYALLON_RESUME);           // 0xA4
	WriteCommand(SSD1306_NORMALDISPLAY);                 // 0xA6

	WriteCommand(SSD1306_DISPLAYON);                 //--turn on oled panel

	WriteCommand(SSD1306_SETLOWCOLUMN | 0x0);  // low col = 0
	WriteCommand(SSD1306_SETHIGHCOLUMN | 0x0);  // hi col = 0
	WriteCommand(SSD1306_SETSTARTLINE | 0x0); // line #0

	for (i = 0; i < SSD1306_LCDHEIGHT / 8; i++)
	{
		// send a bunch of data in one xmission
		WriteCommand(0xB0 + i); //set page address
		WriteCommand(0); //set lower column address
		WriteCommand(0x10); //set higher column address
		for (j = 0; j < 8; j++)
		{

			//Wire.write(0x40);
			addToI2CBuffer(0x40);
			for (k = 0; k < SSD1306_LCDWIDTH / 8; k++)
			{
				//Wire.write(0);
				addToI2CBuffer(0);
			}
			sendI2CBuffer();
		}
	}
}

void OLEDclear(uint8_t x, uint8_t y, uint8_t width, uint8_t height)
{
	uint8_t i = 0;
	uint8_t j = 0;
	uint8_t k = 0;

	WriteCommand(SSD1306_SETLOWCOLUMN | 0x0);  // low col = 0
	WriteCommand(SSD1306_SETHIGHCOLUMN | 0x0);  // hi col = 0
	WriteCommand(SSD1306_SETSTARTLINE | 0x0); // line #0

	height >>= 3;
	width >>= 3;
	y >>= 3;

	for (i = 0; i < height; i++)
	{
		WriteCommand(0xB0 + i + y); //set page address
		WriteCommand((x + 2) & 0xf); //set lower column address
		WriteCommand(0x10 | (x >> 4)); //set higher column address

		for (j = 0; j < 8; j++)
		{
			addToI2CBuffer(0x40);
			for (k = 0; k < width; k++)
			{
				addToI2CBuffer(0);
			}
			sendI2CBuffer();
		}
	}
	setCursor(0, 0);
}

uint8_t write(uint8_t c)
{
	uint8_t d = 0;
	uint8_t i = 0;

	if (c == '\n')
	{
		setCursor(0, m_row + 1);
		return 1;
	}
	else if (c == '\r')
	{
		m_col = 0;
		return 1;
	}

	addToI2CBuffer(0x40);
	if (c > 0x20 && c < 0x7f)
	{
		c -= 0x21;
		for (i = 0; i < 5; i++)
		{
			d = font5x8[c][i];
			addToI2CBuffer(d);
		}
		addToI2CBuffer(0);
	}
	else
	{
		for (i = 6; i > 0; i--)
		{
			addToI2CBuffer(0);
		}
	}
	sendI2CBuffer();

	m_col += 6;
	if (m_col >= 128)
	{
		m_col = 0;
		m_row++;
	}

	return 1;
}

void writeDigit(uint8_t n)
{
	uint8_t i;

	addToI2CBuffer(0x40);
	if (n <= 9)
	{
		n += '0' - 0x21;
		for (i = 0; i < 5; i++)
		{
			//Wire.write(pgm_read_byte(&font5x8[n][i]));
			addToI2CBuffer(font5x8[n][i]);
		}
		//Wire.write(0);
		addToI2CBuffer(0);
	}
	else
	{
		for (i = 0; i < 6; i++)
		{
			addToI2CBuffer(0);
		}
	}
	sendI2CBuffer();
	m_col += 6;
}

void OLEDprint(unsigned char *theString)
{
	unsigned long i = 0;

	while (*(theString + i) != 0)
	{
		if ((*(theString + i) >= 0x21) && (*(theString + i) <= 0x7e))
		{
			write(*(theString + i));
		}
		else
		{
			writeDigit(*(theString + i) - 0x31);
		}
		i++;
	}
}

void OLEDprintwrap(unsigned char *theString)
{
	unsigned long i = 0;

	while (*(theString + i) != 0)
	{
		if ((i > 0) && (i % 20 == 0))
		{
			write('\n');
		}
		if ((*(theString + i) >= 0x21) && (*(theString + i) <= 0x7e))
		{
			write(*(theString + i));
		}
		else
		{
			writeDigit(*(theString + i) - 0x31);
		}
		i++;
	}
}

void OLEDprintln(unsigned char *theString)
{
	unsigned long i = 0;

	while (*(theString + i) != 0)
	{
		if ((*(theString + i) >= 0x21) && (*(theString + i) <= 0x7e))
		{
			write(*(theString + i));
		}
		else
		{
			writeDigit(*(theString + i) - 0x31);
		}
		i++;
	}
	write('\n');
}

void setCursor(uint8_t x, uint8_t y)
{

	m_col = x + 2;
	m_row = y;
	WriteCommand(0xb0 + m_row);
	WriteCommand(m_col & 0xf); //set lower column address
	WriteCommand(0x10 | (m_col >> 4)); //set higher column address
}

void draw(const uint8_t* buffer, uint8_t width, uint8_t height)
{
	uint8_t i = 0;
	uint8_t j = 0;
	uint8_t k = 0;
	const uint8_t *p = buffer;

	WriteCommand(SSD1306_SETLOWCOLUMN | 0x0);  // low col = 0
	WriteCommand(SSD1306_SETHIGHCOLUMN | 0x0);  // hi col = 0
	WriteCommand(SSD1306_SETSTARTLINE | 0x0); // line #0

	height >>= 3;
	width >>= 3;
	for (i = 0; i < height; i++)
	{
		// send a bunch of data in one xmission
		WriteCommand(0xB0 + i + m_row); //set page address
		WriteCommand(m_col & 0xf); //set lower column address
		WriteCommand(0x10 | (m_col >> 4)); //set higher column address

		for (j = 0; j < 8; j++)
		{
			addToI2CBuffer(0x40);
			for (k = 0; k < width; k++, p++)
			{
				addToI2CBuffer(*p);
			}
			sendI2CBuffer();
		}
	}
	m_col += width;
}
